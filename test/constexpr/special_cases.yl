// RUN: compiler %s -res-dump 2>&1 | filecheck %s --match-full-lines
fn binaryLhsKnown(y: number): number {
    return (0.0 && y) + (1.0 || y);
}
// CHECK:       ResolvedBinaryOperator: '+'
// CHECK-NEXT:       | value: 1
// CHECK-NEXT:         ResolvedGroupingExpr:
// CHECK-NEXT:           ResolvedBinaryOperator: '&&'
// CHECK-NEXT:             ResolvedNumberLiteral: '0'
// CHECK-NEXT:             ResolvedDeclRefExpr: @({{.*}}) y
// CHECK-NEXT:         ResolvedGroupingExpr:
// CHECK-NEXT:           ResolvedBinaryOperator: '||'
// CHECK-NEXT:             ResolvedNumberLiteral: '1'
// CHECK-NEXT:             ResolvedDeclRefExpr: @({{.*}}) y

fn unaryNonConst(x: number): number {
    return !x;
}
// CHECK:    ResolvedReturnStmt
// CHECK-NEXT:      ResolvedUnaryOperator: '!'
// CHECK-NEXT:        ResolvedDeclRefExpr: @({{.*}}) x

fn ret(): number {
    return 1.0;
}
// CHECK:    ResolvedReturnStmt
// CHECK-NEXT:      ResolvedNumberLiteral: '1'
// CHECK-NEXT:      | value: 1

fn lhsKnownRhsNot(y: number): number {
    return 1.0 && y;
}
// CHECK:    ResolvedReturnStmt
// CHECK-NEXT:      ResolvedBinaryOperator: '&&'
// CHECK-NEXT:        ResolvedNumberLiteral: '1'
// CHECK-NEXT:        ResolvedDeclRefExpr: @({{.*}}) y

fn lhsUnknownRhsFalse(x: number): number {
    return x && 0.0;
}
// CHECK:    ResolvedReturnStmt
// CHECK-NEXT:      ResolvedBinaryOperator: '&&'
// CHECK-NEXT:      | value: 0
// CHECK-NEXT:        ResolvedDeclRefExpr: @({{.*}}) x
// CHECK-NEXT:        ResolvedNumberLiteral: '0'

fn lhsUnknownRhsTrue(x: number): number {
    return x && (0.0 - 1.0);
}
// CHECK: ResolvedReturnStmt
// CHECK-NEXT:   ResolvedBinaryOperator: '&&'
// CHECK-NEXT:     ResolvedDeclRefExpr: @({{.*}}) x
// CHECK-NEXT:     ResolvedGroupingExpr:
// CHECK-NEXT:       ResolvedBinaryOperator: '-'
// CHECK-NEXT:         ResolvedNumberLiteral: '0'
// CHECK-NEXT:         ResolvedNumberLiteral: '1'

fn main(): void {}

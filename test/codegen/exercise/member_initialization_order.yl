// RUN: compiler %s -llvm-dump 2>&1 | filecheck %s
// RUN: compiler %s -o member_initialization_order && ./member_initialization_order | grep -Plzx '1\n2\n3\n2\n1\n3\n3\n2\n1\n0\n1\n2\n3\n1\n2\n3\n1\n2\n3\n'
struct Color {
  r: number,
  g: number,
  b: number,
}

fn printAndReturn(n: number): number {
  println(n);
  return n;
}

fn main(): unit {
  let c1 = Color {
    r: printAndReturn(1),
    g: printAndReturn(2),
    b: printAndReturn(3),
  };
  // CHECK: %0 = call double @printAndReturn(double 1.000000e+00)
  // CHECK-NEXT: %1 = call double @printAndReturn(double 2.000000e+00)
  // CHECK-NEXT: %2 = call double @printAndReturn(double 3.000000e+00)
  // CHECK-NEXT: %3 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp, i32 0, i32 0
  // CHECK-NEXT: store double %0, ptr %3, align 8
  // CHECK-NEXT: %4 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp, i32 0, i32 1
  // CHECK-NEXT: store double %1, ptr %4, align 8
  // CHECK-NEXT: %5 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp, i32 0, i32 2
  // CHECK-NEXT: store double %2, ptr %5, align 8
  // CHECK-NEXT: call void @llvm.memcpy.p0.p0.i64(ptr align 8 %c1, ptr align 8 %Color.tmp, i64 24, i1 false)

  let c2 = Color {
    g: printAndReturn(2),
    r: printAndReturn(1),
    b: printAndReturn(3),
  };
  // CHECK-NEXT: %6 = call double @printAndReturn(double 2.000000e+00)
  // CHECK-NEXT: %7 = call double @printAndReturn(double 1.000000e+00)
  // CHECK-NEXT: %8 = call double @printAndReturn(double 3.000000e+00)
  // CHECK-NEXT: %9 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp1, i32 0, i32 0
  // CHECK-NEXT: store double %7, ptr %9, align 8
  // CHECK-NEXT: %10 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp1, i32 0, i32 1
  // CHECK-NEXT: store double %6, ptr %10, align 8
  // CHECK-NEXT: %11 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp1, i32 0, i32 2
  // CHECK-NEXT: store double %8, ptr %11, align 8
  // CHECK-NEXT: call void @llvm.memcpy.p0.p0.i64(ptr align 8 %c2, ptr align 8 %Color.tmp1, i64 24, i1 false)

  let c3 = Color {
    b: printAndReturn(3),
    g: printAndReturn(2),
    r: printAndReturn(1),
  };
  // CHECK-NEXT: %12 = call double @printAndReturn(double 3.000000e+00)
  // CHECK-NEXT: %13 = call double @printAndReturn(double 2.000000e+00)
  // CHECK-NEXT: %14 = call double @printAndReturn(double 1.000000e+00)
  // CHECK-NEXT: %15 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp2, i32 0, i32 0
  // CHECK-NEXT: store double %14, ptr %15, align 8
  // CHECK-NEXT: %16 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp2, i32 0, i32 1
  // CHECK-NEXT: store double %13, ptr %16, align 8
  // CHECK-NEXT: %17 = getelementptr inbounds nuw { double, double, double }, ptr %Color.tmp2, i32 0, i32 2
  // CHECK-NEXT: store double %12, ptr %17, align 8
  // CHECK-NEXT: call void @llvm.memcpy.p0.p0.i64(ptr align 8 %c3, ptr align 8 %Color.tmp2, i64 24, i1 false)

  println(0);
  println(c1.r);
  println(c1.g);
  println(c1.b);

  println(c2.r);
  println(c2.g);
  println(c2.b);

  println(c3.r);
  println(c3.g);
  println(c3.b);
}

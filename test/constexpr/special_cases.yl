// RUN: compiler %s -res-dump 2>&1 | filecheck %s --match-full-lines
fn binaryLhsKnown(y: number): number {
    var x: number = 2.1;

    return (0.0 && y) + (1.0 || x);
}
// CHECK:       BinaryOperator: '+'
// CHECK-NEXT:       | value: 1
// CHECK-NEXT:         GroupingExpr:
// CHECK-NEXT:           BinaryOperator: '&&'
// CHECK-NEXT:             NumberLiteral: '0'
// CHECK-NEXT:             DeclRefExpr: @({{.*}}) y
// CHECK-NEXT:         GroupingExpr:
// CHECK-NEXT:           BinaryOperator: '||'
// CHECK-NEXT:             NumberLiteral: '1'
// CHECK-NEXT:             DeclRefExpr: @({{.*}}) x

fn unaryNonConst(): number {
    var x: number = 2.1;

    return !x;
}
// CHECK:    ReturnStmt
// CHECK-NEXT:      UnaryOperator: '!'
// CHECK-NEXT:        DeclRefExpr: @({{.*}}) x

fn ret(): number {
    return 1.0;
}

fn call(): void {
    if !ret() {
        return;
    }
}
// CHECK:    IfStmt
// CHECK-NEXT:      UnaryOperator: '!'
// CHECK-NEXT:        CallExpr: @({{.*}}) ret
// CHECK-NEXT:      Block
// CHECK-NEXT:        ReturnStmt

fn lhsKnownRhsNot(y: number): number {
    return 1.0 && y;
}
// CHECK:    ReturnStmt
// CHECK-NEXT:      BinaryOperator: '&&'
// CHECK-NEXT:        NumberLiteral: '1'
// CHECK-NEXT:        DeclRefExpr: @({{.*}}) y

fn lhsUnknownRhsFalse(x: number): number {
    return x && 0.0;
}
// CHECK:    ReturnStmt
// CHECK-NEXT:      BinaryOperator: '&&'
// CHECK-NEXT:        DeclRefExpr: @({{.*}}) x
// CHECK-NEXT:        NumberLiteral: '0'

fn lhsUnknownRhsTrue(x: number): number {
    return x || 1.0;
}
// CHECK:    ReturnStmt
// CHECK-NEXT:      BinaryOperator: '||'
// CHECK-NEXT:        DeclRefExpr: @({{.*}}) x
// CHECK-NEXT:        NumberLiteral: '1'

fn lhsUnknownRhsFalseOr(x: number): number {
    return x || 0.0;
}
// CHECK:    ReturnStmt
// CHECK-NEXT:      BinaryOperator: '||'
// CHECK-NEXT:        DeclRefExpr: @({{.*}}) x
// CHECK-NEXT:        NumberLiteral: '0'

fn main(): void {}

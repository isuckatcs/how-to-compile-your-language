<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Intro </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                        <div id="toc"></div>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expression</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Handling Arithmetics</h1>
                <p>
                    To be able to handle basic arithmetics, operators like
                    <code>+</code>, <code>-</code>, <code>*</code> and
                    <code>/</code> need to be introduced. These operators also
                    have a precedence level, which the parser also needs to be
                    aware of. It matters whether the expression
                    <code>2 + 3 * 4</code> is parsed like
                    <code>[2 + 3] * 4</code> or <code>2 + [3 * 4]</code>. An
                    additional primary expression, the grouping expression
                    <code>( expression )</code> is also required to allow the
                    developer to override the original precedence.
                </p>
                <p>
                    Operators are expressed in the grammar such that a new
                    non-terminal is introduced for every precedence level and
                    each of these non-terminals expands to the next precedence
                    level one in an increasing order from lowest to highest.
                </p>
                <pre><code>    Precedence    |       Type       |     Symbols
───────────────────────────────────────────────────────
      Highest     │  Multiplicative  │       *,/   
      Lowest      │     Additive     |       +,-</code></pre>
                <pre><code>&lt;expr>
    ::= &lt;additiveExpression>

&lt;additiveExpression>
    ::= &lt;multiplicativeExpression> (('+' | '-') &lt;multiplicativeExpression>)*

&lt;multiplicativeExpression>
    ::= &lt;primaryExpr> (('*' | '/') &lt;primaryExpr>)*</code></pre>
                <p>
                    The purpose of putting the lowest precedence expression to
                    the top and the highest to the bottom is that it's always
                    the left-most non-terminal expanded first, so after the
                    first <code>primaryExpr</code> is parsed, the parser will
                    immediately look for the highest precedence operator first
                    and as it backtracks it checks the lowest one last.
                </p>
                <pre><code>Expression: 2 + 3

1.) go down the stack, parse the primary
|  <i>parseExpr()</i>                                   tok: 2
|    &lt;mul> (('+' | '-') &lt;mul>)*
|  
|    <i>parseMul()</i>
|      &lt;pri> (('*' | '/') &lt;pri>)*    
|    
|      <i>parsePri()</i>                                eat: 2
|        '2'                                     tok: +

2.) go up the stack, match the operator
|      <i>return from parsePri</i>                
|      
|      '2'   (('*' | '/') &lt;pri>)*
|    <i>return from parseMul</i>
|  
|    '2'   (('+' | '-') &lt;mul>)*                  eat: +
|  <i>...</i>         
</code></pre>
                <h2>Operator Precedence Parsing</h2>
                <p>
                    There are however a few drawbacks of using a recursive
                    descent parser to parse operators. In production languages
                    there are more than 2 precedence levels. In Kotlin for
                    example, there are 15. Creating and backtracking 15 stack
                    frames for every operator has a significant impact on
                    performance hence a different approach is used.
                </p>
                <p>
                    Other languages, like Haskell support user-defined operators
                    with custom precedence level and associativity. In a
                    recursive descent parser implementing such feature is
                    tricky, as it requires adding new functions during runtime
                    and modifying which functions are being called next.
                </p>
                <p>
                    Operator precedence parsing, also known as Pratt Parsing is
                    an algorithm that is able to address both of the above
                    drawbacks. Also this parsing technique can easily be
                    combined with recursive descent.
                </p>
                <p>
                    Before implementing this parser however, the lexer needs to
                    be extended with the new operators.
                </p>
                <pre><code>constexpr char singleCharTokens[] = {..., '+', '-', '*'};

enum class TokenKind : char {
  ...
  Slash,

  ...

  Plus = singleCharTokens[8],
  Minus = singleCharTokens[9],
  Asterisk = singleCharTokens[10]
};</code></pre>
                <p>
                    Since comments begin with <code>//</code> the lexer now
                    needs to be able to differentiate between <code>/</code> and
                    <code>//</code>.
                </p>
                <pre><code>Token Lexer::getNextToken() {
  ...

  if (currentChar == '/') {
    if (peekNextChar() != '/')
      return Token{tokenStartLocation, TokenKind::Slash};

    ...
  }

  ...
}</code></pre>
                <p>
                    In the AST each of these operators is represented by one
                    single node, which stores their left and right side and the
                    kind of the token that represents the operator.
                </p>

                <pre><code>struct BinaryOperator : public Expr {
  TokenKind op;
  std::unique_ptr&lt;Expr> lhs;
  std::unique_ptr&lt;Expr> rhs;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        A more elegant representation for operators is creating
                        a dedicated enum of the possible kinds instead of
                        reusing the tokens, but for now the compiler is kept as
                        simple as possible.
                    </p>
                </blockquote>
                <p>
                    When the AST is printed, it is recommended to also print the
                    correct operator. For this a dedicated helper is created
                    that maps the operator tokens to their textual
                    representation.
                </p>
                <pre><code>std::string_view dumpOp(TokenKind op) {
  if (op == TokenKind::Plus)
    return "+";
  if (op == TokenKind::Minus)
    return "-";
  if (op == TokenKind::Asterisk)
    return "*";
  if (op == TokenKind::Slash)
    return "/";

  assert(false && "unexpected operator");

  return "";
}</code></pre>

                <p>
                    The idea is to parse the LHS of an operator first and then
                    parse each of the following operators together with it's
                    RHS. In case of
                    <code>2 + 3 * 4</code> it means parsing <code>2</code>, then
                    <code>+ 3</code> and finally <code>* 4</code>.
                </p>
                <p>
                    When an operator and it's RHS are parsed, it needs to be
                    decided whether that RHS is really the RHS of the current
                    operator, or the LHS of the upcoming one. This is done by
                    checking wether the precedence of the upcoming operator is
                    higher than the current one.
                </p>
                <p>
                    For example in <code>2 + 3 * 4</code> the RHS of
                    <code>+</code> is <code>3</code>. However keeping
                    <code>3</code> as the RHS here would mean, that the
                    expression is parsed as <code>(2 + 3) * 4</code>. Instead,
                    it needs to be considered as the LHS of the upcoming
                    <code>*</code>, because <code>*</code> has a higher
                    precedence than <code>+</code>, so that the expression is
                    parsed correctly as <code>2 + (3 * 4)</code>.
                </p>
                <pre><code>┌─────────────────────────────────────────────────────┐
|         Operator         |        Precedence        |
├─────────────────────────────────────────────────────┤
|           *, /           |             6            |
|           +, -           |             5            |
└─────────────────────────────────────────────────────┘
Expression: 2 + 3 * 4

1.) parse LHS outside the operator precedence parser

  2 + 3 * 4 ;
  ^

2.) invoke the parser with LHS being 2 and parse the 
    next OP and it's RHS

  OP:   (precedence: 0) LHS: 2 RHS:  
  2 + 3 * 4 ;
    ^

  OP: + (precedence: 5) LHS: 2 RHS:  
  2 + 3 * 4 ;
      ^

3.) check the precedence of the upcoming OP 

  OP: + (precedence: 5) LHS: 2 RHS: 3
  2 + 3 * 4 ;
        ^ '*' has a higher precedence (6) than '+' (5)

     4.) halt the parsing of '+' and invoke the parser 
         recursively with LHS set to 3 and the current
         precedence level increased by one

       OP:   (precedence: 6) LHS: 3 RHS:  
       2 + 3 * 4 ;
             ^

     5.) parse the next OP and it's RHS

       OP: * (precedence: 6) LHS: 3 RHS:  
       2 + 3 * 4 ;
               ^
       
       OP: * (precedence: 6) LHS: 3 RHS: 4  
       2 + 3 * 4 ;
                 ^ return BinOp('*', 3, 4)

6.) resume the parsing of '+' and make the returned 
    BinOp it's rhs

  OP: + (precedence: 5) LHS: 2 RHS: 3 * 4
  2 + 3 * 4 ;
            ^ return BinOp('+', 2, BinOp('*', 3, 4))
</code></pre>
                <p>
                    To implement this logic, first a helper is defined that
                    returns the token precedence.
                </p>
                <pre><code>int getTokPrecedence(TokenKind tok) {
  switch (tok) {
  case TokenKind::Asterisk:
  case TokenKind::Slash:
    return 6;
  case TokenKind::Plus:
  case TokenKind::Minus:
    return 5;
  default:
    return -1;
  }
}
};</code></pre>
                <p>
                    The <code>parseExpr()</code> function houses the driver of
                    the operator precedence parser. It first parses the initial
                    primary expression and parses the RHS for it. The
                    <code>parseExprRHS()</code> houses the core logic of the
                    operator precedence parser and as a result it needs to know
                    about the precedence of the current operator. Since
                    initially there is no operator, it's given the
                    <code>0</code> as the current precedence level.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExpr() {
  varOrReturn(lhs, parsePrimary());
  return parseExprRHS(std::move(lhs), 0);
}</code></pre>
                <p>
                    The core of the parser is a loop, that keeps eating the
                    operators and the RHS expression until it finds an operator
                    with a precedence less than the initial precedence.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExprRHS(std::unique_ptr&lt;Expr> lhs,
                                           int precedence) {
  while (true) {
    TokenKind op = nextToken.kind;
    int curOpPrec = getTokPrecedence(op);

    if (curOpPrec < precedence)
      return lhs;

    ...
  }
}</code></pre>
                <p>
                    If the precedence is higher or equal to the initial one,
                    parse the RHS and check the precedence of the upcoming
                    operator. If the precedence of the upcoming operator is
                    higher, the current primary expression is the LHS of that
                    operator, so parse the RHS recursively. Otherwise create a
                    <code>BinaryOperator</code> node and make it the current
                    LHS.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExprRHS(std::unique_ptr&lt;Expr> lhs,
                                           int precedence) {
  while (true) {
    ...
    eatNextToken(); // eat operator

    varOrReturn(rhs, parsePrimary());

    if (curOpPrec < getTokPrecedence(nextToken.kind)) {
      rhs = parseExprRHS(std::move(rhs), curOpPrec + 1);
      if (!rhs)
        return nullptr;
    }

    lhs = std::make_unique&lt;BinaryOperator>(lhs->location, std::move(lhs),
                                           std::move(rhs), op);
  }
}</code></pre>
                <p>
                    Notice how <code>parseExprRHS</code> is called recursively
                    with <code>curOpPrec + 1</code>. The <code>+ 1</code> there
                    controls the associativity of the current operator, with it
                    present, the operator is left associative, without it it's
                    right associative. So far all of the supported operators are
                    left associative.
                </p>
                <pre><code>Expression: 2 + 3 * 4 + 5

// Assume left-associativity
1.) parseExpr()
(2 + 3 * 4 + 5
 ^

2.) LHS = parsePrimary() == 2
(2 + 3 * 4 + 5
   ^

    3.) parseExprRHS(LHS: 2, precedence: 0)
    (2 + 3 * 4 + 5
       ^ 'curTokPrec' (5) >= precedence (0)
    
    4.) eat operator, RHS = parsePrimary() == 3
    (2 + 3 * 4 + 5
           ^ 'curTokPrec' (5) < 'nextTokPrec' (6)
    
        5.) RHS = parseExprRHS(LHS: 3, precedence: 'curTokPrec' + 1 == 6)
        (2 + (3 * 4 + 5
                ^ 'curTokPrec' (6) >= precedence (6)
        
        6.) eat operator, RHS = parsePrimary() == 4
        (2 + (3 * 4) + 5
                     ^ 'curTokPrec' (5) < precedence (6), return

    7.) loop
    ((2 + (3 * 4)) + 5
                   ^ 'curTokPrec' (5) >= precedence (0)

    8.) eat operator, RHS = parsePrimary() == 5
    ((2 + (3 * 4)) + 5)
                       ^ out of tokens, return

// Assume right-associativity
1.) parseExpr()
(2 + 3 * 4 + 5
 ^

2.) LHS = parsePrimary() == 2
(2 + 3 * 4 + 5
   ^

    3.) parseExprRHS(LHS: 2, precedence: 0)
    (2 + 3 * 4 + 5
       ^ 'curTokPrec' (5) >= precedence (0)
    
    4.) eat operator, RHS = parsePrimary() == 3
    (2 + 3 * 4 + 5
           ^ 'curTokPrec' (5) < 'nextTokPrec' (6)
    
        5.) RHS = parseExprRHS(LHS: 3, precedence: 'curTokPrec' == 5)
        (2 + (3 * 4 + 5
                ^ 'curTokPrec' (6) >= precedence (5)
        
        6.) eat operator, RHS = parsePrimary() == 4
        (2 + ((3 * 4) + 5
                      ^ 'curTokPrec' (5) >= precedence (5)

        7.) eat operator, RHS = parsePrimary() == 5
        (2 + ((3 * 4) + 5)
                          ^ out of tokens, return
    8.) create binop with the returned RHS
    (2 + ((3 * 4) + 5))
                       ^
</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        A language can support both left and right associative
                        operators at the same time. C++ is one example, where
                        the arithmetic operators are left associative, while
                        assignments are right associative.
                    </p>
                    <pre><code>((1 + 2) + 3)

(x = (y = 0))</code></pre>
                    <p>
                        With operator precedence parsing it's simple to switch
                        the associativity even in the middle of parsing an
                        expression. It only needs to be ensured that in the
                        recursive call the precedence is not incremented and the
                        recursive call is made even if the next operator has the
                        same precedence level as the current one.
                    </p>
                    <pre><code>while (true) {
  ...
  
  bool isRightAssoc = isRightAssoc(op);
  int nextOpPrec = getTokPrecedence(nextToken.kind);

  if ((curOpPrec < nextOpPrec) || 
      (curOpPrec == nextOpPrec && isRightAssoc)) {
    rhs = parseExprRHS(std::move(rhs), curOpPrec + !isRightAssoc);
    if (!rhs)
      return nullptr;
  }

  ...
}</code></pre>
                </blockquote>
                <h2>Adding Unary Operators</h2>
                <p>
                    Unary operators can have a prefix or postfix form. Currently
                    only the prefix unary negation is supported. The AST node of
                    a unary operator is similar to a binary one in that the RHS
                    and the token kind is used to represent the operator.
                </p>
                <pre><code>struct UnaryOperator : public Expr {
  std::unique_ptr&lt;Expr> rhs;
  TokenKind op;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    Prefix operators have a higher precedence than any of the
                    binary operators and are parsed in their dedicated method.
                </p>
                <pre><code>// &lt;prefixExpression>
//  ::= '-'* &lt;primaryExpr>
std::unique_ptr&lt;Expr> Parser::parsePrefixExpr() {
  Token tok = nextToken;

  if (tok.kind != TokenKind::Minus)
    return parsePrimary();
  eatNextToken(); // eat '-'

  varOrReturn(rhs, parsePrefixExpr());

  return std::make_unique&lt;UnaryOperator>(tok.location, std::move(rhs),
                                         tok.kind);
}</code></pre>
                <p>
                    With this addition the operator precedence parser is
                    modified to call <code>parsePrefixExpr()</code> instead of
                    <code>parsePrimary()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExpr() {
  varOrReturn(lhs, parsePrefixExpr());
  ...
}

std::unique_ptr&lt;Expr> Parser::parseExprRHS(std::unique_ptr&lt;Expr> lhs,
                                           int precedence) {
  while (true) {
    ...

    varOrReturn(rhs, parsePrefixExpr());

    ...
  }
}</code></pre>
                <p>
                    The resolved nodes of both operator is the same as their
                    respective non-resolved counterparts.
                </p>
                <pre><code>struct ResolvedBinaryOperator : public ResolvedExpr {
  TokenKind op;
  std::unique_ptr&lt;ResolvedExpr> lhs;
  std::unique_ptr&lt;ResolvedExpr> rhs;

  // the constructor and dump() are omitted
  ...
};

struct ResolvedUnaryOperator : public ResolvedExpr {
  TokenKind op;
  std::unique_ptr&lt;ResolvedExpr> rhs;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    The resolution of both operators is driven by
                    <code>resolveExpr()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...

  if (const auto *binaryOperator = dynamic_cast&lt;const BinaryOperator *>(&expr))
    return resolveBinaryOperator(*binaryOperator);

  if (const auto *unaryOperator = dynamic_cast&lt;const UnaryOperator *>(&expr))
    return resolveUnaryOperator(*unaryOperator);

  ...
}</code></pre>
                <p>
                    For the unary operator it's sub expression is resolved
                    first. If the resolution succeeds and the kind is not
                    <code>void</code> the corresponding resolved node is
                    returned. Otherwise an error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedUnaryOperator>
Sema::resolveUnaryOperator(const UnaryOperator &unary) {
  varOrReturn(resolvedRHS, resolveExpr(*unary.rhs));

  if (resolvedRHS->type.kind == Type::Kind::Void)
    return report(
        resolvedRHS->location,
        "void expression cannot be used as operand to unary operator");

  return std::make_unique&lt;ResolvedUnaryOperator>(
      unary.location, std::move(resolvedRHS), unary.op);
}</code></pre>
                <p>
                    For binary operators both the LHS and the RHS is resolved.
                    If either of them is of <code>void</code> type and error is
                    reported. Otherwise it should be ensured that the two
                    operands have the same type, but by the type system this is
                    guaranteed if neither of the operands is <code>void</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedBinaryOperator>
Sema::resolveBinaryOperator(const BinaryOperator &binop) {
  varOrReturn(resolvedLHS, resolveExpr(*binop.lhs));
  varOrReturn(resolvedRHS, resolveExpr(*binop.rhs));

  if (resolvedLHS->type.kind == Type::Kind::Void)
    return report(
        resolvedLHS->location,
        "void expression cannot be used as LHS operand to binary operator");

  if (resolvedRHS->type.kind == Type::Kind::Void)
    return report(
        resolvedRHS->location,
        "void expression cannot be used as RHS operand to binary operator");

  assert(resolvedLHS->type.kind == resolvedRHS->type.kind &&
         resolvedLHS->type.kind == Type::Kind::Number &&
         "unexpexted type in binop");

  return std::make_unique&lt;ResolvedBinaryOperator>(
      binop.location, std::move(resolvedLHS), std::move(resolvedRHS), binop.op);
}</code></pre>
                <p>Code generation is driven by <code>generateExpr()</code>.</p>
                <pre><code>llvm::Value *Codegen::generateExpr(const ResolvedExpr &expr) {
  ...

  if (auto *binop = dynamic_cast&lt;const ResolvedBinaryOperator *>(&expr))
    return generateBinaryOperator(*binop);

  if (auto *unop = dynamic_cast&lt;const ResolvedUnaryOperator *>(&expr))
    return generateUnaryOperator(*unop);

  ...
}</code></pre>
                <p>
                    The IRBuilder API provides a function for all of the common
                    unary and binary operators, which makes generating code for
                    operators simple and convenient.
                </p>
                <p>
                    For unary operators the value of their sub expression is
                    generated first and the corresponding operation is performed
                    on the value.
                </p>
                <pre><code>llvm::Value *Codegen::generateUnaryOperator(const ResolvedUnaryOperator &unop) {
  llvm::Value *rhs = generateExpr(*unop.rhs);

  if (unop.op == TokenKind::Minus)
    return builder.CreateFNeg(rhs);

  llvm_unreachable("unknown unary op");
  return nullptr;
}</code></pre>
                <p>
                    Code generation for binary operators is a similar process.
                    Both sides are generated first then the corresponding
                    operation is inserted.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  TokenKind op = binop.op;

  llvm::Value *lhs = generateExpr(*binop.lhs);
  llvm::Value *rhs = generateExpr(*binop.rhs);

  if (op == TokenKind::Plus)
    return builder.CreateFAdd(lhs, rhs);

  if (op == TokenKind::Minus)
    return builder.CreateFSub(lhs, rhs);

  if (op == TokenKind::Asterisk)
    return builder.CreateFMul(lhs, rhs);

  if (op == TokenKind::Slash)
    return builder.CreateFDiv(lhs, rhs);

  llvm_unreachable("unexpected binary operator");
  return nullptr;
}</code></pre>
                <h2>Grouping Expressions</h2>
                <p>
                    Grouping expressions are the last primary expressions
                    supported by the language. They basically serve as wrappers
                    around any arbitrary expression.
                </p>
                <pre><code>struct GroupingExpr : public Expr {
  std::unique_ptr&lt;Expr> expr;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>They are parsed in <code>parsePrimary()</code>.</p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parsePrimary() {
  SourceLocation location = nextToken.location;

  if (nextToken.kind == TokenKind::Lpar) {
    eatNextToken(); // eat '('

    varOrReturn(expr, parseExpr());

    if (nextToken.kind != TokenKind::Rpar)
      return report(nextToken.location, "expected ')'");
    eatNextToken(); // eat ')'

    return std::make_unique&lt;GroupingExpr>(location, std::move(expr));
  }

  ...
}</code></pre>
                <p>
                    The resolved node of the expression is identical to the non
                    resolved one.
                </p>
                <pre><code>struct ResolvedGroupingExpr : public ResolvedExpr {
  std::unique_ptr&lt;ResolvedExpr> expr;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    The resolution of the expression is driven by
                    <code>resolveExpr()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...

  if (const auto *groupingExpr = dynamic_cast&lt;const GroupingExpr *>(&expr))
    return resolveGroupingExpr(*groupingExpr);

  ...
}</code></pre>
                <p>
                    The resolve <code>GroupingExpr</code>, only the wrapped
                    expression needs to be resolved.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedGroupingExpr>
Sema::resolveGroupingExpr(const GroupingExpr &grouping) {
  varOrReturn(resolvedExpr, resolveExpr(*grouping.expr));
  return std::make_unique&lt;ResolvedGroupingExpr>(grouping.location,
                                                std::move(resolvedExpr));
}</code></pre>

                <p>
                    Code generation is identical to the resolution process, the
                    IR is generated for the wrapped expresssion.
                </p>
                <pre><code>llvm::Value *Codegen::generateExpr(const ResolvedExpr &expr) {
  ...

  if (auto *grouping = dynamic_cast&lt;const ResolvedGroupingExpr *>(&expr))
    return generateExpr(*grouping->expr);

  ...
}</code></pre>
                <h2>Adding More Operators</h2>
                <p>
                    Arithmetics are now handled, but a group of logical
                    operators are still missing. These include <code>&&</code>,
                    <code>||</code>, <code>==</code>, <code><</code>,
                    <code>></code> and <code>!</code>. Each of these operators
                    will be a new token in the lexer.
                </p>
                <pre><code>constexpr char singleCharTokens[] = {..., '<', '>', '!'};

enum class TokenKind : char {
  ...

  EqualEqual,
  AmpAmp,
  PipePipe,

  ...
  Lt = singleCharTokens[11],
  Gt = singleCharTokens[12],
  Excl = singleCharTokens[13],
};</code></pre>
                <p>
                    The single character tokens are lexed automatically, but the
                    other three needs a little manual work.
                </p>
                <pre><code>Token Lexer::getNextToken() {
  ...

  if (currentChar == '=' && peekNextChar() == '=') {
    eatNextChar();
    return Token{tokenStartLocation, TokenKind::EqualEqual};
  }

  if (currentChar == '&' && peekNextChar() == '&') {
    eatNextChar();
    return Token{tokenStartLocation, TokenKind::AmpAmp};
  }

  if (currentChar == '|' && peekNextChar() == '|') {
    eatNextChar();
    return Token{tokenStartLocation, TokenKind::PipePipe};
  }

  ...
}</code></pre>
                <p>
                    The parsing of the binary operators will automatically work
                    too, once the precedence tables are filled in.
                </p>
                <pre><code>int getTokPrecedence(TokenKind tok) {
  switch (tok) {
  ...
  case TokenKind::Lt:
  case TokenKind::Gt:
    return 4;
  case TokenKind::EqualEqual:
    return 3;
  case TokenKind::AmpAmp:
    return 2;
  case TokenKind::PipePipe:
    return 1;
  ...
  }
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        The precedence table is hardcoded right now to make
                        retrieving the precedence as quick as possible.
                    </p>
                    <p>
                        If a language however supports user-defined operators,
                        the precedence table needs to be modified during the
                        parsing of the file. In such cases an
                        <code>std::unordered_map</code> or similar data
                        structures can be used.
                    </p>
                </blockquote>
                <p>
                    For the unary <code>!</code>, the corresponding function
                    needs to be taught about the new token.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parsePrefixExpr() {
  ...

  if (tok.kind != TokenKind::Excl && tok.kind != TokenKind::Minus)
    return parsePrimary();
  eatNextToken(); // eat '!' or '-'

  ...
}</code></pre>
                <p>
                    The semantic analyzer is not affected by the change, however
                    the code generator needs to be taught what IR it should
                    generate for each of the new operators.
                </p>
                <p>
                    These operators return logical values, but in the language
                    there is no dedicated bool type. Like in C, if the value is
                    <code>0</code>, it is considered logically false, otherwise
                    the value is logically true. To handle it in LLVM IR, first
                    two helper functions are introduced.
                </p>
                <p>
                    For conversion to bool it's checked if the value is not
                    equal to <code>0</code>.
                </p>
                <pre><code>llvm::Value *Codegen::doubleToBool(llvm::Value *v) {
  return builder.CreateFCmpONE(
      v, llvm::ConstantFP::get(builder.getDoubleTy(), 0.0), "to.bool");
}</code></pre>
                <p>
                    For the conversion back to double a simple cast instruction
                    is inserted.
                </p>
                <pre><code>llvm::Value *Codegen::boolToDouble(llvm::Value *v) {
  return builder.CreateUIToFP(v, builder.getDoubleTy(), "to.double");
}</code></pre>
                <p>
                    The <code>==</code>, <code><</code>, <code>></code> and
                    <code>!</code> operators all have a corresponding
                    instruction in the IRBuilder, so these are handled in their
                    respective generator functions.
                </p>
                <pre><code>llvm::Value *Codegen::generateUnaryOperator(const ResolvedUnaryOperator &unop) {
  ...

  if (unop.op == TokenKind::Excl)
    return boolToDouble(builder.CreateNot(doubleToBool(rhs)));

  ...
}

llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  ...
  llvm::Value *rhs = generateExpr(*binop.rhs);

  if (op == TokenKind::Lt)
    return boolToDouble(builder.CreateFCmpOLT(lhs, rhs));

  if (op == TokenKind::Gt)
    return boolToDouble(builder.CreateFCmpOGT(lhs, rhs));

  if (op == TokenKind::EqualEqual)
    return boolToDouble(builder.CreateFCmpOEQ(lhs, rhs));

  ...
}</code></pre>
                <p>
                    All of the previously seen comparison functions end with
                    three characters starting with <code>O</code>. This
                    <code>O</code> means that an ordered comparison is
                    performed. For example <code>OLT</code> means Ordered Less
                    Than. LLVM also supports and unordered counterpart of each
                    of the instructions like <code>FCmpULT</code>. The
                    difference between the two is that the unordered version
                    also takes <code>NaN</code> (Not a Number) values into
                    account during the comparison, while the ordered version
                    automatically returns false if either of the values is
                    <code>NaN</code>.
                </p>
                <p>
                    To make the operators appear correctly in the AST and
                    resolved tree dumps, the <code>dumpOp()</code> helper is
                    extended to handle them.
                </p>
                <pre><code>std::string_view dumpOp(TokenKind op) {
  ...
  if (op == TokenKind::EqualEqual)
    return "==";
  if (op == TokenKind::AmpAmp)
    return "&&";
  if (op == TokenKind::PipePipe)
    return "||";
  if (op == TokenKind::Lt)
    return "<";
  if (op == TokenKind::Gt)
    return ">";

  assert(op == TokenKind::Excl && "unexpected operator");

  return "!";
}</code></pre>
                <h2>Conditional Binary Operators</h2>
                <p>
                    The conditional binary operators like <code>&&</code> and
                    <code>||</code> on the other hand need special handling
                    because these operators are evaluated lazily.
                </p>
                <p>
                    For <code>&&</code> first the left operand is evaluated and
                    the right operand is only evaluated if the result is true.
                    If the left operand is false, it's already known that the
                    result is false, so there is no need to evaluate the right
                    operand.
                </p>
                <p>
                    For <code>||</code> it's the opposite. If the first operand
                    is true, the result of the operator is true, so the right
                    operand doesn't have to be evaluated.
                </p>
                <p>
                    This is important to keep in mind, since the operands can
                    have side effects too.
                </p>
                <pre><code>fn sideEffect(x: number): number {
    println(x);
    return x;
}

fn true(): number {
    return 1;
}

fn false(): number {
    return 0;
}

fn main(): void {
    true() || sideEffect(0);
    false() && sideEffect(1);
}</code></pre>
                <p>
                    In other words <code>true() || sideEffect(0)</code> is
                    equivalent to the following C++ snippet.
                </p>
                <pre><code>auto lhs = true();

if(!lhs) {
  auto rhs = sideEffect(0);
  return rhs;
}

return true;</code></pre>
                <p>
                    In LLVM IR this will be modelled with introducing a
                    different basic block for the right operand.
                </p>
                <pre><code>entry:
┌────────────────────────────────────────────────┐
│ %0 = call double @true()                       │
│ %to.bool = fcmp one double %0, 0.000000e+00    │
│ br i1 %to.bool, label %or.merge, label %or.rhs │
└────────────────────────────────────────────────┘
              |                         |
              |                         lhs false
              |             or.rhs      |
              |             ┌───────────────────────────────────────────────────┐
              |             │ %1 = call double @sideEffect(double 0.000000e+00) │
              lhs true      | %to.bool1 = fcmp one double %1, 0.000000e+00      │
              |             | br label %or.merge                                │
              |             └───────────────────────────────────────────────────┘
              |                         |
              |                         |
or.merge:     |                         |
┌──────────────────────────────────────────────────────┐
│ %2 = phi i1 [ %to.bool1, %or.rhs ], [ true, %entry ] │
│ ...                                                  │
└──────────────────────────────────────────────────────┘
</code></pre>
                <p>
                    So far implementing this seems simple, but it turns into a
                    not so trivial problem once multiple operators are chained
                    together. Consider the following example and how it's block
                    structure should look like.
                </p>
                <pre><code>x || y && z || w
┌───┐
│ x │──F──┐
└───┘     │
  │     ┌───┐
  │     │ y │──T──┐
  │     └───┘     │
  │       │     ┌───┐
  T       │     │ z │──F──┐
  │       F     └───┘     │
  │       │       │     ┌───┐
  │       │       T     │ w │
  │       │       │     └───┘
  │      ┌─────────┐      │
  └──────│  merge  │──────┘
         └─────────┘</code></pre>
                <p>
                    Before deciding how to generate something like this, let's
                    take a quick look at the AST and draw the edges, where each
                    part should lead.
                </p>
                <pre><code>x || y
     ┌────┐               ┌────┐     
  ┌──│ || │──┐            │ || │     
  │  └────┘  │            └────┘     
┌───┐      ┌───┐     ┌───┐      ┌───┐
│ x │      │ y │     │ x │─────>│ y │
└───┘      └───┘     └───┘      └───┘
                       │          │</code></pre>
                <pre><code>x || y || z
           ┌────┐                     ┌────┐    
        ┌──│ || │──┐                  │ || │
        │  └────┘  │                  └────┘ 
     ┌────┐      ┌───┐          ┌────┐      ┌───┐
  ┌──│ || │──┐   │ z │          │ || │      │ z │
  │  └────┘  │   └───┘          └────┘      └───┘
┌───┐      ┌───┐           ┌───┐      ┌───┐   ^  
│ x │      │ y │           │ x │─────>│ y │───┘
└───┘      └───┘           └───┘      └───┘      
                             │          │</code></pre>
                <pre><code>x || y && z || w
           ┌────┐                    ┌────┐
        ┌──│ || │──┐                 │ || │   
        │  └────┘  │                 └────┘   
     ┌────┐      ┌───┐         ┌────┐      ┌───┐
  ┌──│ || │──┐   │ w │         │ || │      │ w │
  │  └────┘  │   └───┘         └────┘      └───┘
┌───┐      ┌────┐         ┌───┐      ┌────┐  ^
│ x │   ┌──│ && │──┐      │ x │───┐  │ && │  │
└───┘   │  └────┘  │      └───┘   V  └────┘  │
      ┌───┐      ┌───┐      │   ┌───┐      ┌───┐
      │ y │      │ z │      │   │ y │─────>│ z │
      └───┘      └───┘      │   └───┘      └───┘
                            │     │          │
    </code></pre>
                <p>
                    The observation is that for each primary expression, an edge
                    should lead to the merge node and to the next primary
                    expression to the right in the AST. This also means that the
                    next primary expression needs to be put into a new basic
                    block. One of the edges will lead to this new block, while
                    the other will lead to the merge block.
                </p>
                <p>
                    The idea is to create a function that traverses the
                    conditional binop tree and receives the true and the false
                    blocks, the primary expression should lead to after it's
                    evaluation.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  const auto *binop = dynamic_cast&lt;const ResolvedBinaryOperator *>(&op);
  
  ...
  
  assert(!binop && "primary expression expected");

  llvm::Value *val = doubleToBool(generateExpr(op));
  builder.CreateCondBr(val, trueBB, falseBB);
  return;
};</code></pre>
                <p>
                    If a conditional binary operator is visited, a new block is
                    created for the LHS, but this new block needs to be treated
                    differently for <code>||</code> and <code>&&</code>.
                </p>
                <p>
                    In case of <code>||</code>, this block is visited if the
                    left expression is false, so it's called
                    <code>or.lhs.false</code> and for <code>&&</code> the block
                    is visited if the LHS evaluates to true, so it's name is
                    <code>and.lhs.true</code>.
                </p>
                <p>
                    Each of these blocks is inserted into the current function,
                    which is returned by <code>trueBB->getParent()</code>.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  ...
  
  if (binop && binop->op == TokenKind::PipePipe) {
    llvm::BasicBlock *nextBB =
        llvm::BasicBlock::Create(context, "or.lhs.false", trueBB->getParent());
    
    ...
    
    return;
  }

  if (binop && binop->op == TokenKind::AmpAmp) {
    llvm::BasicBlock *nextBB =
        llvm::BasicBlock::Create(context, "and.lhs.true", trueBB->getParent());

    ...

    return;
  }

  ...

};</code></pre>
                <p>
                    With the new block created, the LHS of the operator can be
                    visited by passing this new block as the next false block
                    for <code>||</code> and the next true block for
                    <code>&&</code>.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  ...
  
  if (binop && binop->op == TokenKind::PipePipe) {
    ...
    generateConditionalOperator(*binop->lhs, trueBB, nextBB);
    ...
  }

  if (binop && binop->op == TokenKind::AmpAmp) {
    ...
    generateConditionalOperator(*binop->lhs, nextBB, falseBB);
    ...
  }

  ...

};</code></pre>
                <p>
                    After the code for the LHS is generated, the entry point is
                    set to <code>nextBB</code>, so the next primary to the right
                    is generated into this new block, and the RHS is visited
                    too.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  ...
  
  if (binop && binop->op == TokenKind::PipePipe) {
    ...

    builder.SetInsertPoint(nextBB);
    generateConditionalOperator(*binop->rhs, trueBB, falseBB);
    return;
  }

  if (binop && binop->op == TokenKind::AmpAmp) {
    ...

    builder.SetInsertPoint(nextBB);
    generateConditionalOperator(*binop->rhs, trueBB, falseBB);
    return;
  }

  ...

};</code></pre>
                <p>
                    This function is initially called from
                    <code>generateBinaryOperator()</code>. First it's checked if
                    the operator is an <code>||</code> or an <code>&&</code> and
                    the appropriate basic blocks are created and inserted into
                    the current function.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  TokenKind op = binop.op;

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    llvm::Function *function = getCurrentFunction();
    bool isOr = op == TokenKind::PipePipe;

    auto *rhsTag = isOr ? "or.rhs" : "and.rhs";
    auto *mergeTag = isOr ? "or.merge" : "and.merge";

    auto *rhsBB = llvm::BasicBlock::Create(context, rhsTag, function);
    auto *mergeBB = llvm::BasicBlock::Create(context, mergeTag, function);

    ...
  }

  ...
}</code></pre>
                <p>
                    If the current operator is an <code>||</code>, the true
                    block is the merge block, while the false block is the RHS
                    block. In case of <code>&&</code>, the order is the
                    opposite.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  TokenKind op = binop.op;

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    ...

    llvm::BasicBlock *trueBB = isOr ? mergeBB : rhsBB;
    llvm::BasicBlock *falseBB = isOr ? rhsBB : mergeBB;
    generateConditionalOperator(*binop.lhs, trueBB, falseBB);

    ...
  }

  ...
}</code></pre>
                <p>
                    Then the RHS is visited and a jump to the merge block is
                    inserted into the current block.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  TokenKind op = binop.op;

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    ...

    builder.SetInsertPoint(rhsBB);
    llvm::Value *rhs = doubleToBool(generateExpr(*binop.rhs));
    builder.CreateBr(mergeBB);

    ...
  }

  ...
}</code></pre>
                <p>
                    Since <code>generateExpr()</code> can change the current
                    block <code>rhsBB</code> needs to be retrieved once again
                    (consider <code>x || (y && z)</code>, the insertion point
                    after the function is run is the
                    <code>and.merge</code> block). Then the insertion point is
                    set to the merge block and a phi node is created. From the
                    current block the incoming value is <code>rhs</code>, from
                    every other block it's true in case of <code>||</code> and
                    false for <code>&&</code>.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  TokenKind op = binop.op;

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    ...

    rhsBB = builder.GetInsertBlock();
    builder.SetInsertPoint(mergeBB);
    llvm::PHINode *phi = builder.CreatePHI(builder.getInt1Ty(), 2);

    for (auto it = pred_begin(mergeBB); it != pred_end(mergeBB); ++it) {
      if (*it == rhsBB)
        phi->addIncoming(rhs, rhsBB);
      else
        phi->addIncoming(builder.getInt1(isOr), *it);
    }

    return boolToDouble(phi);
  }

  ...
}</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>

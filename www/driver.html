<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Intro </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li>
                        <a href="driver.html">Driver</a>
                        <div id="toc"></div>
                    </li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                </ul>
            </header>
            <section>
                <h1>The Compiler Driver</h1>
                <p>
                    The driver is an often forgotten part of the compiler,
                    unknown to many developers. This is the component that
                    prepares the environment in which the compiler will run.
                    Validating the input files, providing the compiler with the
                    required settings for compilation, connecting the different
                    parts of the compiler and cleaning up artifacts such as
                    temporary files needed during the compilation are all the
                    responsibilities of the driver.
                </p>
                <p>
                    Many developers believe that when they compile a source file
                    with a well-known compiler like <code>Clang</code>, they
                    invoke the compiler, but in reality they invoke the driver,
                    which will invoke the compiler for them at a later point.
                </p>
                <pre><code>$ clang++ main.cpp</code></pre>
                <p>
                    The above command invokes the <code>clang</code> driver and
                    not the compiler. To see the actual invocations that will be
                    performed the <code>-###</code> (dry-run) option can be
                    passed to the driver.
                </p>
                <pre><code>$ clang++ -### main.cpp
... clang version 14.0.0 ...
/usr/lib/llvm-14/bin/clang ... -o /tmp/main-7cd060.o -x c++ main.cpp
/usr/bin/ld ... -o a.out /tmp/main-7cd060.o -lstdc++</code></pre>
                <p>
                    It is visible that in the background two separate
                    invocations are performed, one for the actual compiler,
                    which produces an object file and one for the linker, which
                    links this object file against the necessary libraries and
                    produces the executable.
                </p>
                <h2>Command Line Interface</h2>
                <p>
                    Since the compiler is invoked from the command line, it is
                    important to have a user friendly command line interface.
                    Upon request the user can be provided with a description on
                    how it works.
                </p>
                <pre><code>void displayHelp() {
  std::cout << "Usage:\n"
            << "  compiler [options] &lt;source_file>\n\n"
            << "Options:\n"
            << "  -h           display this message\n"
            << "  -o &lt;file>    write executable to &lt;file>\n"
            << "  -ast-dump    print the abstract syntax tree\n"
            << "  -res-dump    print the resolved syntax tree\n"
            << "  -llvm-dump   print the llvm module\n";
}</code></pre>
                <p>
                    Since cross source file communication is not supported, the
                    compiler only takes one source file as parameter and an
                    option to display the help message, change the name of the
                    output executable or print it's various intermediate
                    representations.
                </p>
                <h2>Argument Parsing</h2>
                <p>
                    The different compiler options are provided through command
                    line arguments, so to handle them, the arguments need to be
                    parsed first.
                </p>
                <pre><code>struct CompilerOptions {
  std::filesystem::path source;
  std::filesystem::path output;
  bool displayHelp = false;
  bool astDump = false;
  bool resDump = false;
  bool llvmDump = false;
  bool cfgDump = false;
};</code></pre>
                <p>
                    Arguments beginning with a
                    <code>-</code> symbol are assumed to be options. The first
                    argument without a <code>-</code> symbol is assumed to be
                    the source file. Every other argument is unknown.
                </p>
                <pre><code>CompilerOptions parseArguments(int argc, const char **argv) {
  CompilerOptions options;

  int idx = 1;
  while (idx < argc) {
    std::string_view arg = argv[idx];

    if (arg[0] != '-') {
      if (!options.source.empty())
        error("unexpected argument '" + std::string(arg) + '\'');

      options.source = arg;
    } else {
      if (arg == "-h")
        options.displayHelp = true;
      else if (arg == "-o")
        options.output = ++idx >= argc ? "" : argv[idx];
      else if (arg == "-ast-dump")
        options.astDump = true;
      else if (arg == "-res-dump")
        options.resDump = true;
      else if (arg == "-llvm-dump")
        options.llvmDump = true;
      else if (arg == "-cfg-dump")
        options.cfgDump = true;
      else
        error("unexpected option '" + std::string(arg) + '\'');
    }

    ++idx;
  }

  return options;
}</code></pre>
                <p>
                    By convention <code>argv[0]</code> is the command that is
                    used to invoke the program, so the argument parser only has
                    to check the arguments starting with <code>argv[1]</code>.
                </p>
                <p>
                    If any error is encountered within the driver, it displays
                    the message and exits immediately.
                </p>
                <pre><code>[[noreturn]] void error(std::string_view msg) {
  std::cerr << "error: " << msg << '\n';
  std::exit(1);
}</code></pre>
                <h2>Setting Up Compilation</h2>
                <p>
                    After successfully parsing the options, they have to be
                    validated. If the user asked for the help message, it is
                    displayed and the driver exits. If a source file was not
                    specified, or it cannot be opened, the driver exits with an
                    error. Since this language is <i>your language</i>, the
                    source files are expected to have the
                    <code>.yl</code> extension.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  CompilerOptions options = parseArguments(argc, argv);

  if (options.displayHelp) {
    displayHelp();
    return 0;
  }

  if (options.source.empty())
    error("no source file specified");

  if (options.source.extension() != ".yl")
    error("unexpected source file extension");

  std::ifstream file(options.source);
  if (!file)
    error("failed to open '" + options.source.string() + '\'');

  ...
}</code></pre>
                <p>
                    After successfully opening the file, the driver reads it's
                    content and starts passing it through the compilation
                    pipeline.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  ...
  std::stringstream buffer;
  buffer << file.rdbuf();
  SourceFile sourceFile = {options.source.c_str(), buffer.str()};

  Lexer lexer(sourceFile);
  Parser parser(lexer);
  ...
}</code></pre>
                <p>
                    The parser returns the AST and an indicator, whether the AST
                    is complete or not. If the <code>-ast-dump</code> option was
                    specified, the AST is printed otherwise, if the AST is
                    incomplete, compilation cannot be continued.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  ...
  auto [ast, success] = parser.parseSourceFile();

  if (options.astDump) {
    for (auto &&fn : ast)
      fn->dump();
    return 0;
  }

  if (!success)
    return 1;
  ...
}</code></pre>
                <p>
                    If the AST is valid, <code>Sema</code> can be instantiated
                    and the AST can be resolved. If the
                    <code>-res-dump</code> flag was specified, the resolved tree
                    is printed, otherwise if resolution fails, the driver exits.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  ...
  Sema sema(std::move(ast));
  auto resolvedTree = sema.resolveAST();

  if (options.resDump) {
    for (auto &&fn : resolvedTree)
      fn->dump();
    return 0;
  }

  if (resolvedTree.empty())
    return 1;
  ...
}</code></pre>
                <p>
                    If AST resolution succeeds, the LLVM IR can be generated
                    from the resolved tree. If the <code>-llvm-dump</code> flag
                    is specified, the module is dumped.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  ...
  Codegen codegen(std::move(resolvedTree), options.source.c_str());
  llvm::Module *llvmIR = codegen.generateIR();

  if (options.llvmDump) {
    llvmIR->dump();
    return 0;
  }
  ...
}</code></pre>
                <p>
                    To be able to generate the executable, first the module has
                    to be stored in a temporary file. The name of this temporary
                    will be the hash of the file path. By convention an LLVM IR
                    file has the <code>.ll</code> extension.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  ...
  std::stringstream path;
  path << "tmp-" << std::filesystem::hash_value(options.source) << ".ll";
  const std::string &llvmIRPath = path.str();

  std::error_code errorCode;
  llvm::raw_fd_ostream f(llvmIRPath, errorCode);
  llvmIR->print(f, nullptr);
  ...
}</code></pre>
                <p>
                    The reason for choosing the hash of the file as the
                    temporary file name instead of a shorter name like
                    <code>tmp.ll</code> is that if for example a build system
                    wants to compile multiple source files in the same folder at
                    the same time, these temporary files would overwrite each
                    other.
                </p>
                <p>
                    Theoretically these files could overwrite each other too if
                    the same source file is being compiled in the same folder at
                    the same time, though in that case the content of the
                    temporaries still stays the same.
                </p>
                <p>
                    After code generation, the generated LLVM IR is passed to
                    <code>Clang</code> to turn it into an native executable.
                    Finally the temporary IR file is cleaned up and the driver
                    exits with the exit code of <code>Clang</code>.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  ...
  std::stringstream command;
  command << "clang " << llvmIRPath;
  if (!options.output.empty())
    command << " -o " << options.output;

  int ret = std::system(command.str().c_str());
  std::filesystem::remove(llvmIRPath);

  return ret;
}</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>

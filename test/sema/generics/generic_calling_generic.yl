// RUN: compiler %s -res-dump 2>&1 | filecheck %s
fn wrapper<T>(x: T): T {
  return x;
}
// CHECK: FunctionDecl @({{.*}}) wrapper {(T) -> T}
// CHECK-NEXT:   TypeParamDecl @({{.*}}) T
// CHECK-NEXT:   ParamDecl @({{.*}}) x {T}
// CHECK-NEXT:   Block
// CHECK-NEXT:     ReturnStmt
// CHECK-NEXT:       DeclRefExpr @({{.*}}) x {T}

fn foo<U>(x: (U) -> U, y: U): U {
  return x(y);
}
// CHECK: FunctionDecl @({{.*}}) foo {((U) -> U, U) -> U}
// CHECK-NEXT:   TypeParamDecl @({{.*}}) U
// CHECK-NEXT:   ParamDecl @({{.*}}) x {(U) -> U}
// CHECK-NEXT:   ParamDecl @({{.*}}) y {U}
// CHECK-NEXT:   Block
// CHECK-NEXT:     ReturnStmt
// CHECK-NEXT:       CallExpr {U}
// CHECK-NEXT:         DeclRefExpr @({{.*}}) x {(U) -> U}
// CHECK-NEXT:         DeclRefExpr @({{.*}}) y {U}

fn main(): unit {
  let x = foo(wrapper, 20);
  println(x);
}
// CHECK: FunctionDecl @{{.*}}) main {() -> unit}
// CHECK-NEXT:   Block
// CHECK-NEXT:     DeclStmt
// CHECK-NEXT:       VarDecl @({{.*}}) x {number}
// CHECK-NEXT:         CallExpr {number}
// CHECK-NEXT:           DeclRefExpr @({{.*}}) foo {((number) -> number, number) -> number}
// CHECK-NEXT:           DeclRefExpr @({{.*}}) wrapper {(number) -> number}
// CHECK-NEXT:           NumberLiteral '20' {number}
// CHECK-NEXT:           | value: 20
// CHECK-NEXT:     CallExpr {unit}
// CHECK-NEXT:       DeclRefExpr @({{.*}}) println {(number) -> unit}
// CHECK-NEXT:       DeclRefExpr @({{.*}}) x {number}

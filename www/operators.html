<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Prologue </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                        <div id="toc"></div>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                    <br />
                    <li>
                        <a href="structs.html">Exercise: Structs</a>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Handling Arithmetics</h1>
                <p>
                    To be able to handle basic arithmetics, operators like
                    <code>+</code>, <code>-</code>, <code>*</code> and
                    <code>/</code> need to be introduced. These operators also
                    have a precedence level, which the parser needs to be aware
                    of. It matters whether the expression
                    <code>2 + 3 * 4</code> is parsed as
                    <code>(2 + 3) * 4</code> or <code>2 + (3 * 4)</code>. An
                    additional primary expression, the grouping expression
                    <code>( expression )</code> is also required to allow the
                    programmer to override the original precedence.
                </p>
                <p>
                    Operators are expressed in the grammar such that a new
                    non-terminal is introduced for every precedence level and
                    each of these non-terminals expands to the next precedence
                    level in an increasing order from lowest to highest.
                </p>
                <pre><code>    Precedence    |       Type       |     Symbols
───────────────────────────────────────────────────────
      Highest     │  Multiplicative  │       *,/   
      Lowest      │     Additive     |       +,-</code></pre>
                <pre><code>&lt;expr>
    ::= &lt;additiveExpression>

&lt;additiveExpression>
    ::= &lt;multiplicativeExpression> (('+' | '-') &lt;multiplicativeExpression>)*

&lt;multiplicativeExpression>
    ::= &lt;primaryExpr> (('*' | '/') &lt;primaryExpr>)*</code></pre>
                <p>
                    The purpose of putting the lowest precedence expression to
                    the top and the highest to the bottom is that it's always
                    the left-most non-terminal expanded first, so after the
                    first <code>primaryExpression</code> is parsed, the parser
                    will immediately look for the highest precedence operator
                    first and as it backtracks, it checks the lowest one last.
                </p>
                <pre><code>Expression: 2 + 3

1.) go down the stack, parse the primary
|  <i>parseExpr()</i>                                   tok: 2
|    &lt;mul> (('+' | '-') &lt;mul>)*
|  
|    <i>parseMul()</i>
|      &lt;pri> (('*' | '/') &lt;pri>)*    
|    
|      <i>parsePri()</i>                                eat: 2
|        '2'                                     tok: +

2.) go up the stack, match the operator
|      <i>return from parsePri</i>                
|      
|      '2'   (('*' | '/') &lt;pri>)*
|    <i>return from parseMul</i>
|  
|    '2'   (('+' | '-') &lt;mul>)*                  eat: +
|  <i>...</i>         
</code></pre>
                <h2>Operator Precedence Parsing</h2>
                <p>
                    There are however a few drawbacks of using a recursive
                    descent parser to parse operators. In production used
                    languages there are more than 2 precedence levels. In Kotlin
                    for example, there are 15. Creating and backtracking 15
                    stack frames for every operator has a significant impact on
                    performance hence a different approach is used.
                </p>
                <p>
                    Other languages, like Haskell support user-defined operators
                    with custom precedence level and associativity. In a
                    recursive descent parser implementing such a feature is
                    tricky, as it requires adding new functions during runtime
                    and modifying which functions are being called next.
                </p>
                <p>
                    Operator precedence parsing is an algorithm that can address
                    both of the above drawbacks. Also, this parsing technique
                    can easily be combined with recursive descent.
                </p>
                <p>
                    Before implementing this parser, however, the lexer needs to
                    be extended with the new operators.
                </p>
                <pre><code>constexpr char singleCharTokens[] = {..., '+', '-', '*'};

enum class TokenKind : char {
  ...
  Slash,

  ...

  Plus = singleCharTokens[8],
  Minus = singleCharTokens[9],
  Asterisk = singleCharTokens[10]
};</code></pre>
                <p>
                    Since comments begin with <code>//</code> the lexer now
                    needs to be able to differentiate between <code>/</code> and
                    <code>//</code>.
                </p>
                <pre><code>Token Lexer::getNextToken() {
  ...

  if (currentChar == '/') {
    if (peekNextChar() != '/')
      return Token{tokenStartLocation, TokenKind::Slash};

    ...
  }

  ...
}</code></pre>
                <p>
                    In the AST each of these operators is represented by one
                    single node, which stores their left and right side and the
                    kind of the token that represents the operator.
                </p>

                <pre><code>struct BinaryOperator : public Expr {
  std::unique_ptr&lt;Expr> lhs;
  std::unique_ptr&lt;Expr> rhs;
  TokenKind op;

  BinaryOperator(SourceLocation location,
                 std::unique_ptr&lt;Expr> lhs,
                 std::unique_ptr&lt;Expr> rhs,
                 TokenKind op)
      : Expr(location),
        lhs(std::move(lhs)),
        rhs(std::move(rhs)),
        op(op) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        A more elegant representation for operators is creating
                        a dedicated enum of the possible kinds instead of
                        reusing the tokens, but for now, the compiler is kept as
                        simple as possible.
                    </p>
                </blockquote>
                <p>
                    The textual representation of
                    <code>BinaryOperator</code> contains its operands and the
                    stored operator.
                </p>
                <pre><code>void BinaryOperator::dump(size_t level) const {
  std::cerr << indent(level) << "BinaryOperator: '" << getOpStr(op) << '\''
            << '\n';

  lhs->dump(level + 1);
  rhs->dump(level + 1);
}</code></pre>
                <p>
                    To print the correct operator, a dedicated helper is created
                    that maps the operator tokens to their textual
                    representations.
                </p>
                <pre><code>std::string_view getOpStr(TokenKind op) {
  if (op == TokenKind::Plus)
    return "+";
  if (op == TokenKind::Minus)
    return "-";
  if (op == TokenKind::Asterisk)
    return "*";
  if (op == TokenKind::Slash)
    return "/";

  llvm_unreachable("unexpected operator");
}</code></pre>

                <p>
                    The idea is to parse the LHS of an operator first and then
                    parse each of the following operators together with their
                    RHS. In the case of
                    <code>2 + 3 * 4</code>, it means parsing <code>2</code>,
                    then <code>+ 3</code> and finally <code>* 4</code>.
                </p>
                <p>
                    When an operator and its RHS are parsed, it needs to be
                    decided whether that RHS is really the RHS of that operator
                    or the LHS of the upcoming one. This is done by checking
                    whether the precedence of the upcoming operator is higher
                    than the precedence of the current one.
                </p>
                <p>
                    For example in <code>2 + 3 * 4</code> the RHS of
                    <code>+</code> is <code>3</code>. However keeping
                    <code>3</code> as the RHS here would mean, that the
                    expression is parsed as <code>(2 + 3) * 4</code>. Instead,
                    it needs to be considered as the LHS of the upcoming
                    <code>*</code>, because <code>*</code> has a higher
                    precedence than <code>+</code>, so that the expression is
                    parsed correctly as <code>2 + (3 * 4)</code>.
                </p>
                <pre><code>┌─────────────────────────────────────────────────────┐
|         Operator         |        Precedence        |
├─────────────────────────────────────────────────────┤
|           *, /           |             6            |
|           +, -           |             5            |
└─────────────────────────────────────────────────────┘
Expression: 2 + 3 * 4

1.) parse LHS outside the operator precedence parser

  2 + 3 * 4 ;
  ^

2.) invoke the parser with LHS being 2 and parse the 
    next OP and its RHS

  OP:   (precedence: 0) LHS: 2 RHS:  
  2 + 3 * 4 ;
    ^

  OP: + (precedence: 5) LHS: 2 RHS:  
  2 + 3 * 4 ;
      ^

3.) check the precedence of the upcoming OP 

  OP: + (precedence: 5) LHS: 2 RHS: 3
  2 + 3 * 4 ;
        ^ '*' has a higher precedence (6) than '+' (5)

     4.) halt the parsing of '+' and invoke the parser 
         recursively with LHS set to 3 and the current
         precedence level increased by one

       OP:   (precedence: 6) LHS: 3 RHS:  
       2 + 3 * 4 ;
             ^

     5.) parse the next OP and it's RHS

       OP: * (precedence: 6) LHS: 3 RHS:  
       2 + 3 * 4 ;
               ^
       
       OP: * (precedence: 6) LHS: 3 RHS: 4  
       2 + 3 * 4 ;
                 ^ return BinOp('*', 3, 4)

6.) resume the parsing of '+' and make the returned 
    BinOp it's rhs

  OP: + (precedence: 5) LHS: 2 RHS: 3 * 4
  2 + 3 * 4 ;
            ^ return BinOp('+', 2, BinOp('*', 3, 4))
</code></pre>
                <p>
                    To implement this logic, first, a helper is defined that
                    returns the token precedence.
                </p>
                <pre><code>int getTokPrecedence(TokenKind tok) {
  switch (tok) {
  case TokenKind::Asterisk:
  case TokenKind::Slash:
    return 6;
  case TokenKind::Plus:
  case TokenKind::Minus:
    return 5;
  default:
    return -1;
  }
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        The precedence table is hardcoded right now to make
                        retrieving the precedence as quick as possible.
                    </p>
                    <p>
                        If a language however supports user-defined operators,
                        the precedence table needs to be modified during the
                        parsing of the file. In such cases, an
                        <code>std::unordered_map</code> or similar data
                        structure might be used.
                    </p>
                </blockquote>
                <p>
                    The <code>parseExpr()</code> function houses the driver of
                    the operator precedence parser. It first parses the initial
                    primary expression and then parses the RHS for it. The
                    <code>parseExprRHS()</code> houses the core logic of the
                    operator precedence parser and as a result, it needs to know
                    about the precedence of the current operator. Since
                    initially there is no operator, it's given <code>0</code> as
                    the precedence.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExpr() {
  varOrReturn(lhs, parsePrimary());
  return parseExprRHS(std::move(lhs), 0);
}</code></pre>
                <p>
                    The core of the parser is a loop, that keeps eating the
                    operators and their RHS expressions until it finds an
                    operator with a precedence less than the initial precedence.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExprRHS(std::unique_ptr&lt;Expr> lhs,
                                           int precedence) {
  while (true) {
    Token op = nextToken;
    int curOpPrec = getTokPrecedence(op.kind);

    if (curOpPrec < precedence)
      return lhs;

    ...
  }
}</code></pre>
                <p>
                    If the precedence of the current operator is higher than or
                    equal to the initial one, the RHS is parsed and the
                    precedence of the upcoming operator is checked. If the
                    precedence of the upcoming operator is higher, the current
                    primary expression is the LHS of that operator, so it' RHS
                    is parsed recursively. Otherwise, create a
                    <code>BinaryOperator</code> node and make it the current
                    LHS.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExprRHS(std::unique_ptr&lt;Expr> lhs,
                                           int precedence) {
  while (true) {
    ...
    eatNextToken(); // eat operator

    varOrReturn(rhs, parsePrimary());

    if (curOpPrec < getTokPrecedence(nextToken.kind)) {
      rhs = parseExprRHS(std::move(rhs), curOpPrec + 1);
      if (!rhs)
        return nullptr;
    }

    lhs = std::make_unique&lt;BinaryOperator>(op.location, std::move(lhs),
                                           std::move(rhs), op.kind);
  }
}</code></pre>
                <p>
                    Notice how <code>parseExprRHS()</code> is called recursively
                    with <code>curOpPrec + 1</code>. The <code>+ 1</code> there
                    controls the associativity of the current operator, with it
                    present, the operator is left associative, without it it's
                    right-associative. So far all of the supported operators are
                    left-associative.
                </p>
                <pre><code>Expression: 2 + 3 * 4 + 5

// Assume left-associativity
1.) parseExpr()
(2 + 3 * 4 + 5
 ^

2.) LHS = parsePrimary() == 2
(2 + 3 * 4 + 5
   ^

    3.) parseExprRHS(LHS: 2, precedence: 0)
    (2 + 3 * 4 + 5
       ^ 'curTokPrec' (5) >= precedence (0)
    
    4.) eat operator, RHS = parsePrimary() == 3
    (2 + 3 * 4 + 5
           ^ 'curTokPrec' (5) < 'nextTokPrec' (6)
    
        5.) RHS = parseExprRHS(LHS: 3, precedence: 'curTokPrec' + 1 == 6)
        (2 + (3 * 4 + 5
                ^ 'curTokPrec' (6) >= precedence (6)
        
        6.) eat operator, RHS = parsePrimary() == 4
        (2 + (3 * 4) + 5
                     ^ 'curTokPrec' (5) < precedence (6), return

    7.) loop
    ((2 + (3 * 4)) + 5
                   ^ 'curTokPrec' (5) >= precedence (0)

    8.) eat operator, RHS = parsePrimary() == 5
    ((2 + (3 * 4)) + 5)
                       ^ out of tokens, return

// Assume right-associativity
1.) parseExpr()
(2 + 3 * 4 + 5
 ^

2.) LHS = parsePrimary() == 2
(2 + 3 * 4 + 5
   ^

    3.) parseExprRHS(LHS: 2, precedence: 0)
    (2 + 3 * 4 + 5
       ^ 'curTokPrec' (5) >= precedence (0)
    
    4.) eat operator, RHS = parsePrimary() == 3
    (2 + 3 * 4 + 5
           ^ 'curTokPrec' (5) < 'nextTokPrec' (6)
    
        5.) RHS = parseExprRHS(LHS: 3, precedence: 'curTokPrec' == 5)
        (2 + (3 * 4 + 5
                ^ 'curTokPrec' (6) >= precedence (5)
        
        6.) eat operator, RHS = parsePrimary() == 4
        (2 + ((3 * 4) + 5
                      ^ 'curTokPrec' (5) >= precedence (5)

        7.) eat operator, RHS = parsePrimary() == 5
        (2 + ((3 * 4) + 5)
                          ^ out of tokens, return
    8.) create binop with the returned RHS
    (2 + ((3 * 4) + 5))
                       ^
</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        A language can support both left and right-associative
                        operators at the same time. C++ is one example, where
                        the arithmetic operators are left associative, while
                        assignments are right associative.
                    </p>
                    <pre><code>((1 + 2) + 3)

(x = (y = 0))</code></pre>
                    <p>
                        With operator precedence parsing it's simple to switch
                        the associativity even in the middle of parsing an
                        expression. It only needs to be ensured that in the
                        recursive call, the precedence is not incremented and
                        the recursive call is made even if the next operator has
                        the same precedence level as the current one.
                    </p>
                    <pre><code>while (true) {
  ...
  
  bool isRightAssoc = isRightAssoc(op);
  int nextOpPrec = getTokPrecedence(nextToken.kind);

  if ((curOpPrec < nextOpPrec) || 
      (curOpPrec == nextOpPrec && isRightAssoc)) {
    rhs = parseExprRHS(std::move(rhs), curOpPrec + !isRightAssoc);
    if (!rhs)
      return nullptr;
  }

  ...
}</code></pre>
                </blockquote>
                <h2>Adding Unary Operators</h2>
                <p>
                    Unary operators can have a prefix or postfix form.
                    Currently, only the prefix unary negation is supported.
                </p>

                <pre><code>&lt;prefixExpression>
  ::= '-'* &lt;postfixExpression></code></pre>
                <p>
                    The AST node of a unary operator is similar to a binary one
                    in that its operand is stored and the token kind is used to
                    represent the operator.
                </p>
                <pre><code>struct UnaryOperator : public Expr {
  std::unique_ptr&lt;Expr> operand;
  TokenKind op;

  UnaryOperator(SourceLocation location,
                std::unique_ptr&lt;Expr> operand,
                TokenKind op)
      : Expr(location),
        operand(std::move(operand)),
        op(op) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    The textual representation of the node also contains both
                    the operator and its operand.
                </p>
                <pre><code>void UnaryOperator::dump(size_t level) const {
  std::cerr << indent(level) << "UnaryOperator: '" << getOpStr(op) << '\''
            << '\n';

  operand->dump(level + 1);
}</code></pre>
                <p>
                    Prefix operators have higher precedence than any of the
                    binary operators and are parsed in their dedicated method.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parsePrefixExpr() {
  Token tok = nextToken;

  if (tok.kind != TokenKind::Minus)
    return parsePostfixExpr();
  eatNextToken(); // eat '-'

  varOrReturn(rhs, parsePrefixExpr());

  return std::make_unique&lt;UnaryOperator>(tok.location, std::move(rhs),
                                         tok.kind);
}</code></pre>
                <p>
                    With this addition, <code>parseExpr()</code> is modified to
                    call <code>parsePrefixExpr()</code> instead of
                    <code>parsePrimary()</code> when parsing the supposed LHS.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExpr() {
  varOrReturn(lhs, parsePrefixExpr());
  ...
}</code></pre>
                <p>
                    <code>parseExprRHS()</code> is also updated to parse a
                    prefix expression when it expects an RHS.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parseExprRHS(std::unique_ptr&lt;Expr> lhs,
                                           int precedence) {
  while (true) {
    ...

    varOrReturn(rhs, parsePrefixExpr());

    ...
  }
}</code></pre>
                <h2>Processing Operators</h2>
                <p>
                    The resolved node of a <code>BinaryOperator</code> is
                    identical to its non-resolved counterpart.
                </p>
                <pre><code>struct ResolvedBinaryOperator : public ResolvedExpr {
  TokenKind op;
  std::unique_ptr&lt;ResolvedExpr> lhs;
  std::unique_ptr&lt;ResolvedExpr> rhs;

  ResolvedBinaryOperator(SourceLocation location,
                         TokenKind op,
                         std::unique_ptr&lt;ResolvedExpr> lhs,
                         std::unique_ptr&lt;ResolvedExpr> rhs)
      : ResolvedExpr(location, lhs->type),
        op(op),
        lhs(std::move(lhs)),
        rhs(std::move(rhs)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>Its textual representation is also the same.</p>
                <pre><code>void ResolvedBinaryOperator::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedBinaryOperator: '" << getOpStr(op)
            << '\'' << '\n';

  lhs->dump(level + 1);
  rhs->dump(level + 1);
}</code></pre>
                <p>
                    Similarly, a <code>ResolvedUnaryOperator</code> also stores
                    its operand and kind, like its AST node.
                </p>
                <pre><code>struct ResolvedUnaryOperator : public ResolvedExpr {
  TokenKind op;
  std::unique_ptr&lt;ResolvedExpr> operand;

  ResolvedUnaryOperator(SourceLocation location,
                        TokenKind op,
                        std::unique_ptr&lt;ResolvedExpr> operand)
      : ResolvedExpr(location, operand->type),
        op(op),
        operand(std::move(operand)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    Its textual representation also includes both of these
                    fields.
                </p>
                <pre><code>void ResolvedUnaryOperator::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedUnaryOperator: '" << getOpStr(op)
            << '\'' << '\n';

  if (auto val = getConstantValue())
    std::cerr << indent(level) << "| value: " << *val << '\n';

  operand->dump(level + 1);
}</code></pre>
                <p>
                    The resolution of both operators is driven by
                    <code>resolveExpr()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...

  if (const auto *binaryOperator = dynamic_cast&lt;const BinaryOperator *>(&expr))
    return resolveBinaryOperator(*binaryOperator);

  if (const auto *unaryOperator = dynamic_cast&lt;const UnaryOperator *>(&expr))
    return resolveUnaryOperator(*unaryOperator);

  ...
}</code></pre>
                <p>
                    For the unary operator, its operand is resolved first. If
                    the resolution succeeds and the type of the operand is not
                    <code>void</code> the corresponding resolved node is
                    returned. Otherwise, an error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedUnaryOperator>
Sema::resolveUnaryOperator(const UnaryOperator &unary) {
  varOrReturn(resolvedRHS, resolveExpr(*unary.operand));

  if (resolvedRHS->type.kind == Type::Kind::Void)
    return report(
        resolvedRHS->location,
        "void expression cannot be used as an operand to unary operator");

  return std::make_unique&lt;ResolvedUnaryOperator>(unary.location, unary.op,
                                                 std::move(resolvedRHS));
}</code></pre>
                <p>
                    For binary operators, both the LHS and the RHS are resolved.
                    If either of them is of <code>void</code> type an error is
                    reported. Otherwise, it should be checked that the two
                    operands have the same type, but in this case, when neither
                    of the operands is <code>void</code> this is guaranteed by
                    the type system.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedBinaryOperator>
Sema::resolveBinaryOperator(const BinaryOperator &binop) {
  varOrReturn(resolvedLHS, resolveExpr(*binop.lhs));
  varOrReturn(resolvedRHS, resolveExpr(*binop.rhs));

  if (resolvedLHS->type.kind == Type::Kind::Void)
    return report(
        resolvedLHS->location,
        "void expression cannot be used as LHS operand to binary operator");

  if (resolvedRHS->type.kind == Type::Kind::Void)
    return report(
        resolvedRHS->location,
        "void expression cannot be used as RHS operand to binary operator");

  return std::make_unique&lt;ResolvedBinaryOperator>(
      binop.location, std::move(resolvedLHS), std::move(resolvedRHS), binop.op);
}</code></pre>
                <p>Code generation is driven by <code>generateExpr()</code>.</p>
                <pre><code>llvm::Value *Codegen::generateExpr(const ResolvedExpr &expr) {
  ...

  if (auto *binop = dynamic_cast&lt;const ResolvedBinaryOperator *>(&expr))
    return generateBinaryOperator(*binop);

  if (auto *unop = dynamic_cast&lt;const ResolvedUnaryOperator *>(&expr))
    return generateUnaryOperator(*unop);

  ...
}</code></pre>
                <p>
                    The IRBuilder API provides a function for all of the common
                    unary and binary operators, which makes generating code for
                    operators simple and convenient.
                </p>
                <p>
                    For unary operators, the value of their sub-expression is
                    generated first and the corresponding operation is performed
                    on the value.
                </p>
                <pre><code>llvm::Value *Codegen::generateUnaryOperator(const ResolvedUnaryOperator &unop) {
  llvm::Value *rhs = generateExpr(*unop.rhs);

  if (unop.op == TokenKind::Minus)
    return builder.CreateFNeg(rhs);

  llvm_unreachable("unknown unary op");
  return nullptr;
}</code></pre>
                <p>
                    Code generation for binary operators is a similar process.
                    Both sides are generated first then the corresponding
                    operation is inserted.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  TokenKind op = binop.op;

  llvm::Value *lhs = generateExpr(*binop.lhs);
  llvm::Value *rhs = generateExpr(*binop.rhs);

  if (op == TokenKind::Plus)
    return builder.CreateFAdd(lhs, rhs);

  if (op == TokenKind::Minus)
    return builder.CreateFSub(lhs, rhs);

  if (op == TokenKind::Asterisk)
    return builder.CreateFMul(lhs, rhs);

  if (op == TokenKind::Slash)
    return builder.CreateFDiv(lhs, rhs);

  llvm_unreachable("unexpected binary operator");
  return nullptr;
}</code></pre>
                <h2>Grouping Expression</h2>
                <p>
                    Grouping expression is the last primary expression supported
                    by the language. In the grammar, it is a wrapper around an
                    arbitrary expression.
                </p>
                <pre><code>&lt;primaryExpression>
  ::= ...
  |   '(' &lt;expr> ')'</code></pre>
                <p>
                    The AST node representing them is also a wrapper around an
                    <code>Expr</code> node.
                </p>
                <pre><code>struct GroupingExpr : public Expr {
  std::unique_ptr&lt;Expr> expr;

  GroupingExpr(SourceLocation location, std::unique_ptr&lt;Expr> expr)
      : Expr(location),
        expr(std::move(expr)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    Its textual representation is the name of the node and its
                    enclosed expression.
                </p>
                <pre><code>void GroupingExpr::dump(size_t level) const {
  std::cerr << indent(level) << "GroupingExpr:\n";

  expr->dump(level + 1);
}</code></pre>
                <p>
                    Grouping expressions are parsed directly in
                    <code>parsePrimary()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parsePrimary() {
  ...

  if (nextToken.kind == TokenKind::Lpar) {
    eatNextToken(); // eat '('

    varOrReturn(expr, parseExpr());

    matchOrReturn(TokenKind::Rpar, "expected ')'");
    eatNextToken(); // eat ')'

    return std::make_unique&lt;GroupingExpr>(location, std::move(expr));
  }

  ...
}</code></pre>
                <p>
                    The resolved node of the expression is also a wrapper around
                    a <code>ResolvedExpr</code>, similar to the non-resolved
                    one.
                </p>
                <pre><code>struct ResolvedGroupingExpr : public ResolvedExpr {
  std::unique_ptr&lt;ResolvedExpr> expr;

  ResolvedGroupingExpr(SourceLocation location,
                       std::unique_ptr&lt;ResolvedExpr> expr)
      : ResolvedExpr(location, expr->type),
        expr(std::move(expr)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    The textual representation of the resolved node is also
                    identical to its non-resolved counterpart.
                </p>
                <pre><code>void ResolvedGroupingExpr::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedGroupingExpr:\n";

  expr->dump(level + 1);
}</code></pre>
                <p>
                    As for every other expression, the resolution of the
                    grouping expressions is also driven by
                    <code>resolveExpr()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...

  if (const auto *groupingExpr = dynamic_cast&lt;const GroupingExpr *>(&expr))
    return resolveGroupingExpr(*groupingExpr);

  ...
}</code></pre>
                <p>
                    To resolve a <code>GroupingExpr</code>, only its wrapped
                    expression needs to be resolved.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedGroupingExpr>
Sema::resolveGroupingExpr(const GroupingExpr &grouping) {
  varOrReturn(resolvedExpr, resolveExpr(*grouping.expr));
  return std::make_unique&lt;ResolvedGroupingExpr>(grouping.location,
                                                std::move(resolvedExpr));
}</code></pre>

                <p>
                    Code generation is identical to the resolution process, the
                    IR is generated for the wrapped expression.
                </p>
                <pre><code>llvm::Value *Codegen::generateExpr(const ResolvedExpr &expr) {
  ...

  if (auto *grouping = dynamic_cast&lt;const ResolvedGroupingExpr *>(&expr))
    return generateExpr(*grouping->expr);

  ...
}</code></pre>
                <h2>Adding More Operators</h2>
                <p>
                    Arithmetic operators are handled, but a group of logical
                    operators is still missing. These missing operators include
                    <code>==</code>, <code>&&</code>, <code>||</code>,
                    <code><</code>, <code>></code> and <code>!</code>. Each of
                    these operators is also a new token in the lexer.
                </p>
                <pre><code>constexpr char singleCharTokens[] = {..., '<', '>', '!'};

enum class TokenKind : char {
  ...

  EqualEqual,
  AmpAmp,
  PipePipe,

  ...
  Lt = singleCharTokens[11],
  Gt = singleCharTokens[12],
  Excl = singleCharTokens[13],
};</code></pre>
                <p>
                    The single-character tokens are lexed automatically, but for
                    the two-character ones, the characters must be matched
                    manually.
                </p>
                <pre><code>Token Lexer::getNextToken() {
  ...

  if (currentChar == '=' && peekNextChar() == '=') {
    eatNextChar();
    return Token{tokenStartLocation, TokenKind::EqualEqual};
  }

  if (currentChar == '&' && peekNextChar() == '&') {
    eatNextChar();
    return Token{tokenStartLocation, TokenKind::AmpAmp};
  }

  if (currentChar == '|' && peekNextChar() == '|') {
    eatNextChar();
    return Token{tokenStartLocation, TokenKind::PipePipe};
  }

  ...
}</code></pre>
                <p>
                    The parsing of the binary operators is also automatically
                    handled, once the precedence table is filled in.
                </p>
                <pre><code>int getTokPrecedence(TokenKind tok) {
  switch (tok) {
  ...
  case TokenKind::Lt:
  case TokenKind::Gt:
    return 4;
  case TokenKind::EqualEqual:
    return 3;
  case TokenKind::AmpAmp:
    return 2;
  case TokenKind::PipePipe:
    return 1;
  ...
  }
}</code></pre>
                <p>
                    For the unary <code>!</code>, the corresponding parser
                    method needs to be taught about the new token.
                </p>
                <pre><code>std::unique_ptr&lt;Expr> Parser::parsePrefixExpr() {
  ...

  if (tok.kind != TokenKind::Excl && tok.kind != TokenKind::Minus)
    return parsePostfixExpr();
  eatNextToken(); // eat '!' or '-'

  ...
}</code></pre>
                <p>
                    The semantic analyzer is not affected by the change,
                    however, the code generator needs to be taught what
                    instructions it should generate for each of the new
                    operators.
                </p>
                <p>
                    Because these operators are supposed to return logical
                    values, but there is no dedicated logical type in the
                    language, they behave the same way as they do in C. They
                    take and return numeric values and if the value is
                    <code>0</code>, it is considered logically false, otherwise
                    the value is logically true.
                </p>
                <p>
                    LLVM IR however has a dedicated 1-bit integer value, which
                    most of the conditional instructions take as a parameter. To
                    be able to work with these instructions, two helper methods
                    are introduced to convert between numeric and logical
                    values.
                </p>
                <p>
                    For a conversion to a logical value, it's checked if the
                    given numeric value is not equal to <code>0</code> and the
                    result of the comparison is returned.
                </p>
                <pre><code>llvm::Value *Codegen::doubleToBool(llvm::Value *v) {
  return builder.CreateFCmpONE(
      v, llvm::ConstantFP::get(builder.getDoubleTy(), 0.0), "to.bool");
}</code></pre>
                <p>
                    For the conversion back to double a simple cast instruction
                    is inserted.
                </p>
                <pre><code>llvm::Value *Codegen::boolToDouble(llvm::Value *v) {
  return builder.CreateUIToFP(v, builder.getDoubleTy(), "to.double");
}</code></pre>
                <p>
                    The <code>!</code> operator negates the logical value of its
                    operand, so the operand is converted to bool before the
                    negation is performed. Once the value is negated, it is
                    promoted back to a numeric value, because the language can
                    only work with numbers.
                </p>
                <pre><code>llvm::Value *Codegen::generateUnaryOperator(const ResolvedUnaryOperator &unop) {
  ...

  if (unop.op == TokenKind::Excl)
    return boolToDouble(builder.CreateNot(doubleToBool(rhs)));

  ...
}</code></pre>
                <p>
                    The <code>==</code>, <code><</code>, <code>></code> binary
                    operators also have a corresponding instruction in the
                    <code>IRBuilder</code> which can be used similarly, between
                    converting the operand to bool and promoting it back to
                    double.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  ...

  if (op == TokenKind::Lt)
    return boolToDouble(builder.CreateFCmpOLT(lhs, rhs));

  if (op == TokenKind::Gt)
    return boolToDouble(builder.CreateFCmpOGT(lhs, rhs));

  if (op == TokenKind::EqualEqual)
    return boolToDouble(builder.CreateFCmpOEQ(lhs, rhs));

  ...
}</code></pre>
                <p>
                    All of the previously seen comparison functions end with
                    three characters starting with <code>O</code>. This
                    <code>O</code> means that an ordered comparison is
                    performed. For example, <code>OLT</code> means Ordered Less
                    Than.
                </p>
                <p>
                    LLVM also supports an unordered counterpart for each of the
                    instructions like <code>FCmpULT</code>. The difference
                    between the two is that the unordered version also takes
                    <code>NaN</code> (Not a Number) values into account during
                    the comparison, while the ordered version automatically
                    returns false if either of the values is <code>NaN</code>.
                </p>
                <p>
                    One last change to make is making these operators appear
                    correctly in the AST and resolved tree dumps, so the
                    <code>getOpStr()</code> function is extended to handle them.
                </p>
                <pre><code>std::string_view getOpStr(TokenKind op) {
  ...
  if (op == TokenKind::EqualEqual)
    return "==";
  if (op == TokenKind::AmpAmp)
    return "&&";
  if (op == TokenKind::PipePipe)
    return "||";
  if (op == TokenKind::Lt)
    return "<";
  if (op == TokenKind::Gt)
    return ">";
  if (op == TokenKind::Excl)
    return "!";
  ...
}</code></pre>
                <h2>Conditional Binary Operators</h2>
                <p>
                    The conditional binary operators like <code>&&</code> and
                    <code>||</code> on the other hand need special handling
                    because these operators are evaluated lazily.
                </p>
                <p>
                    For <code>&&</code> first the left operand is evaluated and
                    the right operand is only evaluated if the result is true.
                    If the left operand is false, it's already known that the
                    result of the operator is false, so there is no need to
                    evaluate the right operand.
                </p>
                <p>
                    For <code>||</code> it's the opposite. If the first operand
                    is true, the result of the operator is true, so the right
                    operand doesn't have to be evaluated.
                </p>
                <p>
                    This is important to keep in mind since the operands can
                    have side effects too. In the following program for example
                    nothing should be printed to the standard output.
                </p>
                <pre><code>fn sideEffect(x: number): number {
    println(x);
    return x;
}

fn true(): number {
    return 1;
}

fn false(): number {
    return 0;
}

fn main(): void {
    true() || sideEffect(0);
    false() && sideEffect(1);
}</code></pre>
                <p>
                    A different way to look at
                    <code>true() || sideEffect(0)</code> is through the
                    following C++ snippet.
                </p>
                <pre><code>auto lhs = true();

if(!lhs) {
  auto rhs = sideEffect(0);
  return rhs;
}

return true;</code></pre>
                <p>
                    In LLVM IR this is modelled by introducing a different basic
                    block for the right operand.
                </p>
                <pre><code>entry:
┌────────────────────────────────────────────────┐
│ %0 = call double @true()                       │
│ %to.bool = fcmp one double %0, 0.000000e+00    │
│ br i1 %to.bool, label %or.merge, label %or.rhs │
└────────────────────────────────────────────────┘
              |                         |
              |                         lhs false
              |             or.rhs      |
              |             ┌───────────────────────────────────────────────────┐
              |             │ %1 = call double @sideEffect(double 0.000000e+00) │
              lhs true      | %to.bool1 = fcmp one double %1, 0.000000e+00      │
              |             | br label %or.merge                                │
              |             └───────────────────────────────────────────────────┘
              |                         |
              |                         |
or.merge:     |                         |
┌──────────────────────────────────────────────────────┐
│ %2 = phi i1 [ %to.bool1, %or.rhs ], [ true, %entry ] │
│ ...                                                  │
└──────────────────────────────────────────────────────┘
</code></pre>
                <p>
                    So far implementing this seems simple, but it turns into a
                    not-so-trivial problem once multiple operators are chained
                    together. Consider the following example and how it's block
                    structure should look like.
                </p>
                <pre><code>x || y || z || w
┌───┐
│ x │──F──┐
└───┘     │
  │     ┌───┐
  │     │ y │──F──┐
  │     └───┘     │
  │       │     ┌───┐
  T       │     │ z │──F──┐
  │       T     └───┘     │
  │       │       │     ┌───┐
  │       │       T     │ w │
  │       │       │     └───┘
  │      ┌─────────┐      │
  └──────│  merge  │──────┘
         └─────────┘</code></pre>
                <p>
                    Before deciding how to generate something like this, let's
                    take a quick look at one more example and which AST node
                    each operand should lead to.
                </p>
                <pre><code>x || y && z || w
           ┌────┐                    ┌────┐
        ┌──│ || │──┐                 │ || │   
        │  └────┘  │                 └────┘   
     ┌────┐      ┌───┐         ┌────┐      ┌───┐
  ┌──│ || │──┐   │ w │         │ || │      │ w │<┐
  │  └────┘  │   └───┘         └────┘      └───┘ │
┌───┐      ┌────┐         ┌───┐      ┌────┐  ^   │
│ x │   ┌──│ && │──┐      │ x │───┐  │ && │  │   │
└───┘   │  └────┘  │      └───┘   V  └────┘  │   │
      ┌───┐      ┌───┐      │   ┌───┐      ┌───┐ │
      │ y │      │ z │      │   │ y │─────>│ z │ │
      └───┘      └───┘      │   └───┘      └───┘ │
                            │     └───────── │ ──┘</code></pre>
                <p>
                    This latest example shows that when operators are combined,
                    the resulting execution paths can end up being quite
                    complicated, so there is no need to look for patterns, just
                    stick to a good old recursive solution.
                </p>
                <p>
                    The idea is to create a function that traverses the AST of a
                    conditional binary operator and receives the two blocks the
                    execution should jump to when the current operand evaluates
                    to true and false.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  const auto *binop = dynamic_cast&lt;const ResolvedBinaryOperator *>(&op);
  
  if (binop)
    return;
  
  llvm::Value *val = doubleToBool(generateExpr(op));
  builder.CreateCondBr(val, trueBB, falseBB);
};</code></pre>
                <p>
                    When a conditional binary operator is visited, a new block
                    is created for the RHS, but this new block needs to be
                    treated differently for <code>||</code> and <code>&&</code>.
                </p>
                <p>
                    In the case of <code>||</code>, this block is visited if the
                    left operand is false, so it's called
                    <code>or.lhs.false</code> and for <code>&&</code> the block
                    is visited if the LHS evaluates to true, so its name is
                    <code>and.lhs.true</code>. Each of these blocks is then
                    inserted into the current function.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  llvm::Function *function = getCurrentFunction();
  ...
  
  if (binop && binop->op == TokenKind::PipePipe) {
    llvm::BasicBlock *nextBB =
        llvm::BasicBlock::Create(context, "or.lhs.false", function);
    
    ...
    
    return;
  }

  if (binop && binop->op == TokenKind::AmpAmp) {
    llvm::BasicBlock *nextBB =
        llvm::BasicBlock::Create(context, "and.lhs.true", function);

    ...

    return;
  }

  ...

};</code></pre>
                <p>
                    The <code>getCurrentFunction()</code> helper extracts the
                    current function out of the builder.
                </p>
                <pre><code>llvm::Function *Codegen::getCurrentFunction() {
  return builder.GetInsertBlock()->getParent();
};</code></pre>
                <p>
                    With the new block created, the LHS of the operator can be
                    visited by making this new block the next false block for
                    <code>||</code> and the next true block for <code>&&</code>.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  ...
  
  if (binop && binop->op == TokenKind::PipePipe) {
    ...
    generateConditionalOperator(*binop->lhs, trueBB, nextBB);
    ...
  }

  if (binop && binop->op == TokenKind::AmpAmp) {
    ...
    generateConditionalOperator(*binop->lhs, nextBB, falseBB);
    ...
  }

  ...

};</code></pre>
                <p>
                    After the instructions for the LHS are generated, the
                    insertion point is set to <code>nextBB</code>, so the next
                    operand on the right is generated into this new block when
                    it is visited.
                </p>
                <pre><code>void Codegen::generateConditionalOperator(const ResolvedExpr &op,
                                          llvm::BasicBlock *trueBB,
                                          llvm::BasicBlock *falseBB) {
  ...
  
  if (binop && binop->op == TokenKind::PipePipe) {
    ...

    builder.SetInsertPoint(nextBB);
    generateConditionalOperator(*binop->rhs, trueBB, falseBB);
    return;
  }

  if (binop && binop->op == TokenKind::AmpAmp) {
    ...

    builder.SetInsertPoint(nextBB);
    generateConditionalOperator(*binop->rhs, trueBB, falseBB);
    return;
  }

  ...

};</code></pre>
                <p>
                    This function is initially called from
                    <code>generateBinaryOperator()</code>, which first checks if
                    the operator is an <code>||</code> or an <code>&&</code> and
                    creates the initial true and false blocks.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  TokenKind op = binop.op;

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    llvm::Function *function = getCurrentFunction();
    bool isOr = op == TokenKind::PipePipe;

    auto *rhsTag = isOr ? "or.rhs" : "and.rhs";
    auto *mergeTag = isOr ? "or.merge" : "and.merge";

    auto *rhsBB = llvm::BasicBlock::Create(context, rhsTag, function);
    auto *mergeBB = llvm::BasicBlock::Create(context, mergeTag, function);

    ...
  }

  ...
}</code></pre>
                <p>
                    If the current operator is an <code>||</code>, the true
                    block is the merge block, while the false block is the RHS
                    block. Remember, when the left operand is true, the right
                    one is not evaluated. In the case of <code>&&</code>, the
                    order is the opposite.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  ...

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    ...

    llvm::BasicBlock *trueBB = isOr ? mergeBB : rhsBB;
    llvm::BasicBlock *falseBB = isOr ? rhsBB : mergeBB;
    generateConditionalOperator(*binop.lhs, trueBB, falseBB);

    ...
  }

  ...
}</code></pre>
                <p>
                    Then the RHS is visited and a jump to the merge block is
                    inserted into the current block.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  ...

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    ...

    builder.SetInsertPoint(rhsBB);
    llvm::Value *rhs = doubleToBool(generateExpr(*binop.rhs));
    builder.CreateBr(mergeBB);

    ...
  }

  ...
}</code></pre>
                <p>
                    Since <code>generateExpr()</code> can change the current
                    block, <code>rhsBB</code> needs to be retrieved once again
                    (consider <code>x || y && z</code> where the insertion point
                    after the function is run is the
                    <code>and.merge</code> block). Then the insertion point is
                    set to the merge block and a phi node is created.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  ...

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    ...

    rhsBB = builder.GetInsertBlock();
    builder.SetInsertPoint(mergeBB);
    llvm::PHINode *phi = builder.CreatePHI(builder.getInt1Ty(), 2);

    ...
  }

  ...
}</code></pre>
                <p>
                    From <code>rhsBB</code> the incoming value of the result is
                    <code>rhs</code>, while from every other block, it's true in
                    case of <code>||</code> and false for <code>&&</code>.
                </p>
                <pre><code>llvm::Value *
Codegen::generateBinaryOperator(const ResolvedBinaryOperator &binop) {
  ...

  if (op == TokenKind::AmpAmp || op == TokenKind::PipePipe) {
    ...

    for (auto it = pred_begin(mergeBB); it != pred_end(mergeBB); ++it) {
      if (*it == rhsBB)
        phi->addIncoming(rhs, rhsBB);
      else
        phi->addIncoming(builder.getInt1(isOr), *it);
    }

    return boolToDouble(phi);
  }

  ...
}</code></pre>
                <p>
                    For a better understanding consider
                    <code>r = x || y || z;</code> and its simplified LLVM IR
                    representation.
                </p>
                <pre><code>┌────────────────┐
│ bx:            │
│  $x            │─────────┐
│  br $x, bm, by │         │
└────────────────┘         v
         │        ┌────────────────┐
         │        │ by:            │
         │        │  $y            │─────────┐
         │        │  br $y, bm, bz │         │
         │        └────────────────┘         v
         │                 │        ┌────────────────┐
         │                 │        │ bz:            │
         │                 │        │  $z            │
         │                 │        │  br bm         │
         │                 │        └────────────────┘
         │                 │                 │
         v                 v                 v
┌────────────────────────────────────────────────────┐
│ bm:                                                │
│  $r = phi [$x, bx], [$y, by], [$z, bz]             │
└────────────────────────────────────────────────────┘
</code></pre>
                <p>
                    From the <code>bx</code> block, the execution only jumps to
                    the <code>bm</code> block, if <code>$x</code> is true.
                    Similarly, from the <code>by</code> block to jump to
                    <code>bm</code>, <code>$y</code> must be true.
                </p>
                <p>
                    When <code>bz</code> is reached, <code>$x</code> and
                    <code>$y</code> are guaranteed to be false. Since the
                    results are <code>||</code>-d together and
                    <code>false || false || z</code> can be simplified to
                    <code>z</code>, the result only depends on the value of
                    <code>$z</code>.
                </p>
                <p>
                    These observations are what
                    <code>generateBinaryOperator()</code> uses during the
                    creation of the <code>phi</code> node, which yields the
                    following result.
                </p>
                <pre><code>$r = phi [true, bx], [true, by], [$z, bz]</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
